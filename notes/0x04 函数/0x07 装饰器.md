# è£…é¥°å™¨

Decorator

> GitHub@[orca-j35](https://github.com/orca-j35)ï¼Œæ‰€æœ‰ç¬”è®°å‡æ‰˜ç®¡äº [python_notes](https://github.com/orca-j35/python_notes) ä»“åº“
>
> å‚è€ƒï¼š
>
> - ï¹æµç•…çš„ Pythonï¹-> ç¬¬ 7 ç«  å‡½æ•°è£…é¥°å™¨å’Œé—­åŒ…
> - [Primer on Python Decorators â€“ Real Python](https://realpython.com/primer-on-python-decorators/)
>
> æ‰©å±•é˜…è¯»ï¼š
>
> - [è£…é¥°å™¨ â€” Intermediate Python](https://eastlakeside.gitbooks.io/interpy-zh/content/decorators/)
> - [ä¼šæ‰“æ‰®çš„è£…é¥°å™¨ Â· Python ä¹‹æ—…](https://funhacks.net/explore-python/Functional/decorator.html)
> - [DRY Principles through Python Decorators](http://y.tsutsumi.io/dry-principles-through-python-decorators.html)
> - [è£…é¥°å™¨ - å»–é›ªå³°](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318435599930270c0381a3b44db991cd6d858064ac0000)
> - [Python çš„é—­åŒ…å’Œè£…é¥°å™¨](https://segmentfault.com/a/1190000004461404)
> - http://www.cnblogs.com/vamei/archive/2013/02/16/2820212.html
> - [PEP 318 -- Decorators for Functions and Methods](https://www.python.org/dev/peps/pep-0318/)
> - [PEP 318: Decorators for Functions and Methods - Whatâ€™s New in Python 2.4](https://docs.python.org/3.7/whatsnew/2.4.html?highlight=classmethod#pep-318-decorators-for-functions-and-methods)
> - [PEP 3129 -- Class Decorators](https://www.python.org/dev/peps/pep-3129/)
> - [Python Decorator Wiki](https://wiki.python.org/moin/PythonDecorators)
> - See the documentation for [function definitions](https://docs.python.org/3.7/reference/compound_stmts.html#function) and [class definitions](https://docs.python.org/3.7/reference/compound_stmts.html#class) for more about decorators.
>
> æœ‰å…³"å¦‚ä½•åœ¨ Python ä¸­å®ç°è£…é¥°å™¨"çš„å†å²è®¨è®ºï¼Œè¯·å‚é˜… [PEP 318](https://www.python.org/dev/peps/pep-0318/) å’Œ [Python Decorator Wiki](https://wiki.python.org/moin/PythonDecorators)ã€‚åœ¨  [Python Decorator Library](https://wiki.python.org/moin/PythonDecoratorLibrary) ä¸­å¯çœ‹åˆ°æ›´å¤šä¸è£…é¥°å™¨ç›¸å…³çš„ä¾‹å­ã€‚ [`decorator`](https://github.com/micheles/decorator) æ¨¡å—å¯ä»¥ç®€åŒ–è£…é¥°å™¨çš„åˆ›å»ºè¿‡ç¨‹ï¼Œå…¶[æ–‡æ¡£](https://decorator.readthedocs.io/)ä¸­åŒ…å«æ›´å¤šæœ‰å…³è£…é¥°å™¨çš„ç¤ºä¾‹ã€‚

è£…é¥°å™¨([*decorator*](https://docs.python.org/3.7/glossary.html#term-decorator))å±äºå¯è°ƒç”¨çš„å¯¹è±¡ï¼Œå¯é€šè¿‡å‡½æ•°æˆ–ç±»å®ç°ï¼›è£…é¥°å™¨çš„å‚æ•°å¯ä»¥æ˜¯å¦ä¸€ä¸ªå‡½æ•°ï¼Œä¹Ÿå¯ä»¥æ˜¯æŸä¸ªç±»ã€‚

## 1. è¯­æ³•ç³–

è£…é¥°å™¨è¯­æ³• `@xxxx` å…¶å®æ˜¯ä¸€ç§è¯­æ³•ç³–(*Syntactic* *Sugar*)ï¼Œä½†ä½ åŒæ ·å¯ä»¥ç›´æ¥è°ƒç”¨è£…é¥°å™¨ã€‚å› æ­¤ï¼Œå¦‚æœéœ€è¦è£…é¥°æŸä¸ªå·²å­˜åœ¨çš„å¯¹è±¡ï¼Œä¾¿å¯é€šè¿‡ç›´æ¥è°ƒç”¨è£…é¥°å™¨çš„æ–¹å¼æ¥å®ç°ã€‚æ¯”å¦‚ï¼Œå¯é€šè¿‡è°ƒç”¨è£…é¥°å™¨æ¥è£…é¥°å†…ç½®åº“ä¸­çš„å‡½æ•°ã€‚

### 1.1 ç®€å•è£…é¥°å™¨

å¯¹äºç”¨å‡½æ•°å®ç°çš„ç®€å•è£…é¥°å™¨ `@decorate` è€Œè¨€ï¼Œå…¶ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š

```python
import functools
def decorate(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # Do something before
        value = func(*args, **kwargs)
        # Do something after
        return value
    return wrapper

@decorate
def target():
    print('running target()')
```

ä½¿ç”¨è¯­æ³•ç³– `@decorate` ä¸ç›´æ¥è°ƒç”¨ `decorate()` ç­‰æ•ˆï¼š

```python
def target():
    print('running target()')
target = decorate(target)
```

### 1.2 è£…é¥°å™¨å·¥å‚å‡½æ•°

å¯¹äºç”¨å‡½æ•°å®ç°çš„è£…é¥°å™¨å·¥å‚å‡½æ•° `@factory(...)` è€Œè¨€ï¼Œå…¶ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š

```python
import functools
def factory(arg_1, ...):
    def decorator_name(func):
        @functools.wraps(func)
        def wrapper_name(*args, **kwargs):
            # Do something before using arg_1, ...
            value = func(*args, **kwargs)
            # Do something after using arg_1, ...
            return value
        return wrapper_name
    return decorator_name

@factory(arg_1, ...)
def target():
    print('running target()')
```

ä½¿ç”¨è¯­æ³•ç³– `@factory(arg_1, ...)` ä¸ç›´æ¥è°ƒç”¨ `factory(arg_1, ...)` ç­‰æ•ˆï¼š

```python
def target():
    print('running target()')
target = factory(arg_1, ...)(target)
```

### 1.3 å æ”¾è£…é¥°å™¨

```python
@d1
@d2
def f():
    print('f')
```

ç­‰æ•ˆäºï¼š

```python
def f():
    print('f')
f = d1(d2(f))
```

## 2. ä½•æ—¶æ‰§è¡Œè£…é¥°å™¨

è£…é¥°å™¨ä¼šåœ¨åŸå§‹å‡½æ•°å®šä¹‰ä¹‹åç«‹å³æ‰§è¡Œï¼Œå› æ­¤å½“æˆ‘ä»¬å¯¼å…¥æ¨¡å—æ—¶ä¾¿ä¼šæ‰§è¡Œå…¶ä¸­çš„è£…é¥°å™¨ï¼Œä½†æ˜¯è¢«è£…é¥°åçš„å‡½æ•°å¯¹è±¡åªæœ‰åœ¨è¢«è°ƒç”¨æ—¶æ‰ä¼šè¢«æ‰§è¡Œã€‚

```python
# registration.py
# BEGIN REGISTRATION
registry = []  # ä¿å­˜è¢«@registerè£…é¥°è¿‡çš„å‡½æ•°çš„å¼•ç”¨
def register(func):  # è£…é¥°å™¨ä»¥å‡½æ•°ä½œä¸ºå‚æ•°
    print('running register(%s)' % func)
    registry.append(func)
    return func

@register # åœ¨å®šä¹‰f1ä¹‹åï¼Œç«‹å³è¿›è¡Œè£…é¥°
def f1():print('running f1()')

@register
def f2():print('running f2()')

def f3():print('running f3()')

def main():
    print('running main()')
    print('registry ->', registry)
    f1()
    f2()
    f3()

if __name__=='__main__':
    main()
# END REGISTRATION
```

ä½œä¸ºè„šæœ¬è¿è¡Œæ—¶ï¼Œå³ `$ python3 registration.py`ï¼š

```python
running register(<function f1 at 0x0000026286F5BAE8>)
running register(<function f2 at 0x0000026287038F28>)
running main()
registry -> [<function f1 at 0x0000026286F5BAE8>, <function f2 at 0x0000026287038F28>]
running f1()
running f2()
running f3()
```

ä½œä¸ºæ¨¡å—å¯¼å…¥æ—¶ï¼š

```python
>>> import registration
running register(<function f1 at 0x10063b1e0>)
running register(<function f2 at 0x10063b268>)
```

### 2.1 è£…é¥°é€’å½’å‡½æ•°

ç”±äºè£…é¥°å™¨ä¼šåœ¨åŸå§‹å‡½æ•°å®šä¹‰ä¹‹åç«‹å³æ‰§è¡Œï¼Œå› æ­¤å…¨å±€ç¬¦å·è¡¨ä¸­å¼•ç”¨çš„æ˜¯ç»è¿‡è£…é¥°çš„å‡½æ•°ï¼Œåœ¨é€’å½’å‡½æ•°ä¸­è°ƒç”¨çš„å‡½æ•°ä¹Ÿæ˜¯ç»è¿‡è£…é¥°çš„å‡½æ•°ï¼š

```python
# clockdeco.py
import time
def clock(func):
    def clocked(*args):
        t0 = time.time()
        result = func(*args) # funcæ˜¯clockedçš„è‡ªç”±å˜é‡
        elapsed = time.time() - t0
        name = func.__name__
        arg_str = ', '.join(repr(arg) for arg in args)
        print('[%0.8fs] %s(%s) -> %r' % (elapsed, name, arg_str, result))
        return result
    return clocked # ç”¨clockedæ›¿æ¢func
```

ä½¿ç”¨ `clock` è£…é¥°å™¨ï¼š

```python
# clockdeco_demo.py
import time
from clockdeco import clock

@clock
def snooze(seconds):
    time.sleep(seconds)

@clock
def factorial(n):
    return 1 if n < 2 else n*factorial(n-1)
'''ç­‰ä»·äº
def factorial(n):
    return 1 if n < 2 else n*factorial(n-1)
factorial = clock(factorial)
'''

if __name__=='__main__':
    print('*' * 40, 'Calling snooze(.123)')
    snooze(.123)
    print('*' * 40, 'Calling factorial(6)')
    print('6! =', factorial(6))
    print(factorial) # factorialå·²æŒ‡å‘clock
```

è¾“å‡ºï¼š

```python
**************************************** Calling snooze(.123)
[0.12399006s] snooze(0.123) -> None
**************************************** Calling factorial(6)
[0.00000000s] factorial(1) -> 1
[0.00022674s] factorial(2) -> 2
[0.00036836s] factorial(3) -> 6
[0.00044465s] factorial(4) -> 24
[0.00044465s] factorial(5) -> 120
[0.00094700s] factorial(6) -> 720
6! = 720
<function clock.<locals>.clocked at 0x000001D45933C7B8>
```

`clockdeco.py` ä¸­å®ç°çš„ `clock` è£…é¥°å™¨æœ‰å‡ ä¸ªç¼ºç‚¹ï¼šä¸æ”¯æŒå…³é”®å­—å‚æ•°ï¼Œè€Œä¸”é®ç›–äº†è¢«è£…é¥°å‡½æ•°çš„ `__name__` å’Œ `__doc__` å±æ€§ã€‚ä¸‹é¢ä½¿ç”¨ [`functools.wraps`](https://docs.python.org/3.6/library/functools.html#functools.wraps) è£…é¥°å™¨æŠŠç›¸å…³çš„å±æ€§ä» `func` å¤åˆ¶åˆ° `clocked` ä¸­ã€‚æ­¤å¤–ï¼Œè¿™ä¸ªæ–°ç‰ˆè¿˜èƒ½æ­£ç¡®å¤„ç†å…³é”®å­—å‚æ•°ã€‚

```python
# clockdeco2.py

import time
import functools

def clock(func):
    @functools.wraps(func)
    def clocked(*args, **kwargs): # æ”¯æŒå…³é”®å­—å‚æ•°
        t0 = time.time()
        result = func(*args, **kwargs)
        elapsed = time.time() - t0
        name = func.__name__
        arg_lst = []
        if args:
            arg_lst.append(', '.join(repr(arg) for arg in args))
        if kwargs:
            pairs = ['%s=%r' % (k, w) for k, w in sorted(kwargs.items())]
            arg_lst.append(', '.join(pairs))
        arg_str = ', '.join(arg_lst)
        print('[%0.8fs] %s(%s) -> %r ' % (elapsed, name, arg_str, result))
        return result
    return clocked
```

## 3. functions as Decorators

ä½¿ç”¨å‡½æ•°å®ç°è£…é¥°å™¨æ—¶ï¼Œå…¶å‚æ•°å’Œè¿”å›å€¼å‡ä¸ºå¯è°ƒç”¨å¯¹è±¡ã€‚

### 3.1 åŸºç¡€æ¨¡æ¿

Template for basic decorator that can modify the decorated function:

```python
import functools

def name(func):
    @functools.wraps(func)
    def wrapper_name(*args, **kwargs): 
        '''inner wrapper function
        ä½¿ç”¨*args, **kwargså‘funcä¼ é€’å‚æ•°'''
        # Do something before
        value = func(*args, **kwargs)
        # Do something after
        return value
    return wrapper_name
```

Example: A timer decorator that prints the runtime of a function. 

```python
import functools
import time
def timer(func):
    """Print the runtime of the function"""
    @functools.wraps(func)
    def wrapper_timer(*args, **kwargs):
        start_time = time.perf_counter()
        value = func(*args, **kwargs)
        end_time = time.perf_counter()
        run_time = end_time - start_time
        print(f"Run time: {run_time:.4f} secs")
        return value
    return wrapper_timer
```

### 3.2 è£…é¥°å™¨å·¥å‚å‡½æ•°

å¦‚æœéœ€è¦å‘è£…é¥°å™¨è½¬é€’å‚æ•°ï¼Œåˆ™åº”åˆ›å»ºä¸€ä¸ªè£…é¥°å™¨å·¥å‚å‡½æ•°ã€‚ä½ éœ€è¦ä½¿ç”¨å·¥å‚å‡½æ•°æ¥æ¥å—ç›¸å…³å‚æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ªè£…é¥°å™¨ï¼Œç„¶åå†æŠŠè¯¥è£…é¥°å™¨åº”ç”¨åˆ°éœ€è¦è£…é¥°çš„å‡½æ•°ä¸Šã€‚ä¸ºäº†ä¾¿äºç†è§£ï¼Œå…ˆç»™å‡ºä¸€ä¸ªæ— å‚æ•°çš„è£…é¥°å™¨ï¼š

```python
# registration.py 
registry = []

def register(func):
    print('running register(%s)' % func)
    registry.append(func)
    return func

@register
def f1():
    print('running f1()')

print('running main()')
print('registry ->', registry)
f1()
```

ä¸ºäº†ä¾¿äºå¯ç”¨æˆ–ç¦ç”¨ `register` æ‰§è¡Œçš„å‡½æ•°æ³¨å†ŒåŠŸèƒ½ï¼Œéœ€è¦ä¸ºå®ƒæä¾›ä¸€ä¸ªå¯é€‰å‚æ•° `active`ã€‚å½“è¯¥å‚æ•°è®¾ä¸º `False` æ—¶ï¼Œåˆ™ä¸ä¼šæ³¨å†Œè¢«è£…é¥°çš„å‡½æ•°ã€‚ä»æ¦‚å¿µä¸Šçœ‹ï¼Œä¸‹é¢è¿™ä¸ªæ–°çš„ `register` å‡½æ•°å¹¶ä¸æ˜¯è£…é¥°å™¨ï¼Œè€Œæ˜¯è£…é¥°å™¨å·¥å‚å‡½æ•°ï¼Œéœ€è¦è°ƒç”¨å®ƒæ‰ä¼šè¿”å›çœŸæ­£çš„è£…é¥°å™¨ã€‚

```python
# BEGIN REGISTRATION_PARAM

registry = set()  # ä½¿ç”¨setï¼Œå¯è·å¾—æ›´å¿«çš„æ·»åŠ å’Œåˆ é™¤é€Ÿåº¦

def register(active=True):  # è£…é¥°å™¨å·¥å‚å‡½æ•°ï¼Œç”¨äºæ¥å—å‚æ•°
    def decorate(func):  # çœŸæ­£çš„è£…é¥°å™¨ï¼Œå…¶å‚æ•°æ˜¯ä¸€ä¸ªå‡½æ•°ã€‚
        print('running register(active=%s)->decorate(%s)'
              % (active, func))
        if active:
            registry.add(func)
        else:
            registry.discard(func)
            
        return func  # è£…é¥°å™¨éœ€è¿”å›ä¸€ä¸ªå¯è°ƒç”¨å¯¹è±¡
    return decorate  # è£…é¥°å™¨å·¥å‚å‡½æ•°ä¼šåˆ›å»ºä¸€ä¸ªè£…é¥°å™¨

@register(active=False)  # è°ƒç”¨å·¥å‚å‡½æ•°æ¥è·å–è£…é¥°å™¨
def f1():
    print('running f1()')

@register()  # è°ƒç”¨å·¥å‚å‡½æ•°æ¥è·å–è£…é¥°å™¨
def f2():
    print('running f2()')

def f3():
    print('running f3()')

# END REGISTRATION_PARAM
```

è¾“å‡ºï¼š

```python
running register(active=False)->decorate(<function f1 at 0x000002A30EFDC950>)
running register(active=True)->decorate(<function f2 at 0x000002A30EFDC9D8>)
```

å¦‚æœä¸ä½¿ç”¨ `@` å¥æ³•ï¼Œé‚£å°±è¦åƒå¸¸è§„å‡½æ•°é‚£æ ·ä½¿ç”¨ `register`ï¼›è‹¥æƒ³æŠŠ `f` æ·»åŠ åˆ° `registry` ä¸­ï¼Œåˆ™è£…é¥° `f` å‡½æ•°çš„å¥æ³•æ˜¯ `register()(f)`ï¼›ä¸æƒ³æ·»åŠ ï¼ˆæˆ–æŠŠå®ƒåˆ é™¤ï¼‰çš„è¯ï¼Œå¥æ³•æ˜¯ `register(active=False)(f)`ã€‚

#### a. å·¥å‚å‡½æ•°æ¨¡æ¿

- If you want your decorator to take arguments, create a decorator factory that can create decorators:

    ```python
    import functools
    def name(arg_1, ...):
        def decorator_name(func):
            @functools.wraps(func)
            def wrapper_name(*args, **kwargs): # inner wrapper function
                # ä½¿ç”¨*args, **kwargså‘funcä¼ é€’å‚æ•°
                # Do something before using arg_1, ...
                value = func(*args, **kwargs)
                # Do something after using arg_1, ...
                return value
            return wrapper_name
        return decorator_name
    ```

    Example: Rate limit your code by sleeping a given amount of seconds before calling the function. 

    ```python
    import functools
    import time
    def slow_down(rate):
        """Sleep before calling the function"""
        def decorator_slow_down(func):
            @functools.wraps(func)
            def wrapper_slow_down(*args, **kwargs):
                time.sleep(rate)
                return func(*args, **kwargs)
            return wrapper_slow_down
        return decorator_slow_down
    ```

- If you want your decorator to be able to be **called with or without arguments**, you need a dummy argument, _func, that is set automatically if the decorator is called without arguments: 

    ```python
    def name(_func=None, *, arg_1=val_1, ...):
      def decorator_name(func):
          @functools.wraps(func)
          def wrapper_name(*args, **kwargs):
              # Do something before using arg_1, ...
              value = func(*args, **kwargs)
              # Do something after using arg_1, ...
              return value
          return wrapper_name
      if _func is None:
          return decorator_name
      else:
          return decorator_name(_func)
    ```

    Example: Rate limit your code by sleeping an optionally given amount of seconds before calling the function. 

    ```python
    import functools
    import time
    def slow_down(_func=None, *, rate=1):
        """Sleep before calling the function"""
        def decorator_slow_down(func):
            @functools.wraps(func)
            def wrapper_slow_down(*args, **kwargs):
                time.sleep(rate)
                return func(*args, **kwargs)
            return wrapper_slow_down
        if _func is None:
            return decorator_slow_down
        else:
            return decorator_slow_down(_func)
    ```


### 3.3 å†…çœ `@wraps`

å†…çœ([*Introspection*](https://en.wikipedia.org/wiki/Type_introspection))æ˜¯å¯¹è±¡åœ¨è¿è¡Œæ—¶äº†è§£å…¶è‡ªèº«å±æ€§çš„èƒ½åŠ›ã€‚ä¾‹å¦‚ï¼Œå‡½æ•°çŸ¥é“è‡ªå·±çš„åç§°å’Œæ–‡æ¡£ï¼š

```python
>>> print
<built-in function print>

>>> print.__name__
'print'

>>> help(print)
Help on built-in function print in module builtins:

print(...)
    <full help message>
```

ç»è¿‡è£…é¥°åçš„å‡½æ•°ä¸èƒ½æ­£å¸¸ä½¿ç”¨å†…çœåŠŸèƒ½ï¼Œæ­¤æ—¶å‡½æ•°åä¼šæŒ‡å‘è£…é¥°å™¨å†…éƒ¨çš„ `wrapper` å‡½æ•°ï¼Œä¾‹å¦‚ï¼š

```python
import functools
import time
def timer(func):
    """Print the runtime of the function"""
    # @functools.wraps(func)
    def wrapper_timer(*args, **kwargs): # å†…éƒ¨wrapperå‡½æ•°
        start_time = time.perf_counter()
        value = func(*args, **kwargs)
        end_time = time.perf_counter()
        run_time = end_time - start_time
        print(f"Run time: {run_time:.4f} secs")
        return value
    return wrapper_timer

@timer
def func():
    '''æµ‹è¯•å‡½æ•°'''
    return [i**2 for i in range(1000)]
print(func)
#> <function timer.<locals>.wrapper_timer at 0x0000029AD86FA048>
print(func.__name__)
#> wrapper_timer
help(func)
'''>
Help on function wrapper_timer in module __main__:

wrapper_timer(*args, **kwargs)
    å†…éƒ¨wrapperå‡½æ•°
'''
```

ä¸ºäº†è®©è£…é¥°å™¨å†…éƒ¨ `wrapper` çš„å‡½æ•°èƒ½å¤Ÿä¿ç•™åŸå§‹å‡½æ•°ä¸­çš„ä¿¡æ¯ï¼Œåˆ™éœ€è¦åœ¨ `wrapper` å‡½æ•°ä¸Šä½¿ç”¨ [`@functools.wraps`](https://docs.python.org/library/functools.html#functools.wraps) è£…é¥°å™¨â€”â€”ä»æŠ€æœ¯ä¸Šæ¥è®²ï¼Œ`@functools.wraps` è£…é¥°å™¨ä¼šä½¿ç”¨ `functools.update_wrapper()` å‡½æ•°æ¥æ›´æ–°å†…çœä¸­ä½¿ç”¨çš„ç‰¹æ®Šå±æ€§ï¼Œå¦‚ `__name__` å’Œ `__doc__`ã€‚

```python
import functools
import time
def timer(func):
    """Print the runtime of the function"""
    # @functools.wraps(func)
    def wrapper_timer(*args, **kwargs): # å†…éƒ¨wrapperå‡½æ•°
        start_time = time.perf_counter()
        value = func(*args, **kwargs)
        end_time = time.perf_counter()
        run_time = end_time - start_time
        print(f"Run time: {run_time:.4f} secs")
        return value
    return wrapper_timer

@timer
def func():
    '''æµ‹è¯•å‡½æ•°'''
    return [i**2 for i in range(1000)]
print(func)
#> <function func at 0x000002265237A048>
print(func.__name__)
#> func
help(func)
'''>
Help on function func in module __main__:

func()
    æµ‹è¯•å‡½æ•°
'''
```

`@functools.wraps` è¿˜æœ‰ä¸€ä¸ªé‡è¦çš„ç‰¹ç‚¹ï¼šå¯ä»¥é€šè¿‡ `__wrapped__` å†æ¬¡è®¿é—®åŸå‡½æ•°ï¼Œå¦‚ `func.__wrapped__(*args,**kwargs)`ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼š

- å¦‚æœæœ‰å¤šä¸ªè£…é¥°å™¨åŒæ—¶ç”¨ä¸Šè¿°æ–¹æ³•è£…é¥°æŸä¸ªå‡½æ•°ï¼Œåˆ™ `__wrapped__` å¾—åˆ°çš„ç»“æœä¸å¯é¢„çŸ¥ã€‚ä¹Ÿå¯èƒ½æ˜¯åŸå‡½æ•°ï¼Œæˆ–è§£é™¤ä¸€ä¸ªè£…é¥°å™¨æ•ˆæœã€‚
- å†…ç½®çš„è£…é¥°å™¨ `@staticmethod` å’Œ `@classmethod` å°±æ²¡æœ‰éµå¾ªè¿™ä¸ªçº¦å®š (å®ƒä»¬æŠŠåŸå§‹å‡½æ•°å­˜å‚¨åœ¨å±æ€§ `__func__` ä¸­)ã€‚

### 3.4 çŠ¶æ€ç»´æŠ¤

æœ‰æ—¶å¯èƒ½ä¼šéœ€è¦è£…é¥°å™¨èƒ½å¤Ÿç»´æŠ¤æŸäº›çŠ¶æ€ã€‚æ¯”å¦‚ï¼Œåˆ©ç”¨è£…é¥°å™¨æ¥è·Ÿè¸ªå‡½æ•°çš„è°ƒç”¨æ¬¡æ•°ã€‚å¦‚æœéœ€è¦ç»´æŠ¤çš„ä¿¡æ¯è¾ƒä¸ºç®€å•ï¼Œå¯ä»¥ä½¿ç”¨**å‡½æ•°å±æ€§**([*function* *attributes*](https://www.python.org/dev/peps/pep-0232/))æ¥å®Œæˆï¼›å¦‚æœæƒ…å†µæ¯”è¾ƒå¤æ‚ï¼Œåˆ™éœ€è¦ä½¿ç”¨ç±»è£…é¥°å™¨æ¥å®Œæˆå·¥ä½œ(è¯¦è§"4.3 çŠ¶æ€ç»´æŠ¤")ã€‚è¿™é‡Œä»…å±•ç¤ºä½¿ç”¨å‡½æ•°å±æ€§çš„æƒ…å†µï¼š

```python
import functools

def count_calls(func):
    @functools.wraps(func)
    def wrapper_count_calls(*args, **kwargs):
        wrapper_count_calls.num_calls += 1
        print(f"Call {wrapper_count_calls.num_calls} of {func.__name__!r}")
        return func(*args, **kwargs)
    wrapper_count_calls.num_calls = 0
    return wrapper_count_calls

@count_calls
def say_whee():
    print("Whee!")
```

è·Ÿè¸ªè°ƒç”¨æ¬¡æ•°çš„çŠ¶æ€ä¿¡æ¯è¢«å‚¨å­˜åœ¨ `wrapper ` å‡½æ•°çš„ `.num_calls` å±æ€§ä¸­ï¼š

```python
>>> say_whee()
Call 1 of 'say_whee'
Whee!

>>> say_whee()
Call 2 of 'say_whee'
Whee!

>>> say_whee.num_calls
2
```



## 4. Classes as Decorators

### 4.1 åŸºç¡€æ¨¡æ¿

If you need your decorator to maintain state, use a class as a decorator: 

```python
import functools
class Name:
    def __init__(self, func):
        functools.update_wrapper(self, func)
        self.func = func
        # Initialize state attributes
    def __call__(self, *args, **kwargs):
        # Update state attributes
        return self.func(*args, **kwargs)
```

Example: Count the number of times the decorated function is called. 

```python
import functools
class CountCalls:
    def __init__(self, func):
        functools.update_wrapper(self, func)
        self.func = func
        self.num_calls = 0
    def __call__(self, *args, **kwargs):
        self.num_calls += 1
        print(f"Call {self.num_calls}")
        return self.func(*args, **kwargs)
```

ç”¨ç±»å®ç°è£…é¥°å™¨æ—¶ï¼Œéœ€è°ƒç”¨ `functools.update_wrapper(self, func)` æ¥ä¿ç•™åŸå§‹å‡½æ•°çš„å†…çœä¿¡æ¯ï¼Œå¦‚ `__name__` å’Œ `__doc__`ã€‚

### 4.2 è£…é¥°å™¨å·¥å‚ç±»

å¦‚æœéœ€è¦å‘è£…é¥°å™¨è½¬é€’å‚æ•°ï¼Œåˆ™åº”åˆ›å»ºä¸€ä¸ªè£…é¥°å™¨å·¥å‚ç±»ï¼Œå…¶å®ä¾‹æ˜¯ä¸€ä¸ªè£…é¥°å™¨ã€‚ä½ éœ€è¦ä½¿ç”¨å·¥å‚ç±»æ¥æ¥å—ç›¸å…³å‚æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ªè£…é¥°å™¨(ç±»å·¥å‚çš„å®ä¾‹)ï¼Œç„¶åå†æŠŠè¯¥è£…é¥°å™¨åº”ç”¨åˆ°éœ€è¦è£…é¥°çš„å¯¹è±¡ä¸Šã€‚

#### a. å·¥å‚ç±»æ¨¡æ¿

```python
import functools
class Name:
    def __init__(self, arg_1, ...):
        self.arg_1 = arg_1
        # ...
        # Initialize state attributes
    def __call__(self, func):
        @functools.wraps(func)
        def wrapper_name(*args, **kwargs): # inner wrapper function
            # ä½¿ç”¨*args, **kwargså‘funcä¼ é€’å‚æ•°
            # Do something before using arg_1, ...
            value = func(*args, **kwargs)
            # Do something after using arg_1, ...
            return value
        return wrapper_name
```

ç¤ºä¾‹ - å®ç°ä¸€ä¸ªè£…é¥°å™¨å·¥å‚ç±»ï¼Œå…¶å®ä¾‹å¯ä»¥è¿”å›ä¸€ä¸ªå¸¦æ—¥å¿—æ‰“å°åŠŸèƒ½çš„ `wrapper` å‡½æ•°ï¼š

```python
from functools import wraps
class logit(object):
    def __init__(self, logfile='out.log'):
        self.logfile = logfile

    def __call__(self, func):
        @wraps(func) # wraps
        def wrapped_function(*args, **kwargs):
            log_string = func.__name__ + " was called"
            print(log_string)
            # æ‰“å¼€logfileå¹¶å†™å…¥
            with open(self.logfile, 'a') as opened_file:
                # ç°åœ¨å°†æ—¥å¿—æ‰“åˆ°æŒ‡å®šçš„æ–‡ä»¶
                opened_file.write(log_string + '\n')
            # ç°åœ¨ï¼Œå‘é€ä¸€ä¸ªé€šçŸ¥
            self.notify()
            return func(*args, **kwargs)
        return wrapped_function

    def notify(self):
        # logitåªæ‰“æ—¥å¿—ï¼Œä¸åšåˆ«çš„
        pass
```

å‚è€ƒè‡ª: https://eastlakeside.gitbooks.io/interpy-zh/content/decorators/deco_class.html

### 4.3 çŠ¶æ€ç»´æŠ¤

æœ‰æ—¶å¯èƒ½ä¼šéœ€è¦è£…é¥°å™¨èƒ½å¤Ÿç»´æŠ¤æŸäº›çŠ¶æ€ï¼Œå¦‚æœéœ€è¦ç»´æŠ¤çš„ä¿¡æ¯è¾ƒä¸ºç®€å•ï¼Œå¯ä»¥ä½¿ç”¨å‡½æ•°å±æ€§([*function* *attributes*](https://www.python.org/dev/peps/pep-0232/))æ¥å®Œæˆ(è¯¦è§"3.4 çŠ¶æ€ç»´æŠ¤")ï¼›å¦‚æœæƒ…å†µæ¯”è¾ƒå¤æ‚ï¼Œåˆ™éœ€è¦ä½¿ç”¨ç±»è£…é¥°å™¨æ¥å®Œæˆå·¥ä½œã€‚

```python
import functools

class CountCalls:
    def __init__(self, func):
        functools.update_wrapper(self, func)
        self.func = func
        self.num_calls = 0

    def __call__(self, *args, **kwargs):
        self.num_calls += 1
        print(f"Call {self.num_calls} of {self.func.__name__!r}")
        return self.func(*args, **kwargs)

@CountCalls
def say_whee():
    print("Whee!")
'''
>>> say_whee()
Call 1 of 'say_whee'
Whee!

>>> say_whee()
Call 2 of 'say_whee'
Whee!

>>> say_whee.num_calls
2
'''
```



## 5. å¯¹ç±»è¿›è¡Œè£…é¥°

> ç›¸å…³é˜…è¯»:ï¹æµç•…çš„ Pythonï¹-> ç¬¬ 21 ç«  ç±»å…ƒç¼–ç¨‹

æˆ‘ä»¬è¿˜å¯ä»¥å¯¹æ•´ä¸ªç±»è¿›è¡Œè£…é¥°ã€‚ä¾‹å¦‚ï¼Œåœ¨ Python 3.7 ä¸­å¯ä½¿ç”¨  [`dataclasses`](https://realpython.com/python-data-classes/) æ¨¡å—æ¥è£…é¥°ç±»ï¼š

```python
from dataclasses import dataclass

@dataclass
class PlayingCard:
    rank: str
    suit: str
```

ä¸Šè¿°ä»£ç ç­‰æ•ˆäºï¼š

```python
PlayingCard = dataclass(PlayingCard)
```

ç±»æœ¬èº«å°±æ˜¯å¯è°ƒç”¨å¯¹è±¡(ç”¨äºåˆ›å»ºç±»å®ä¾‹)ï¼Œæ‰€ä»¥ä»¥ä¸‹æ¨¡æ¿å‡å¯ç”¨æ¥å¯¹ç±»è¿›è¡Œè£…é¥°ï¼š

- 3.1 åŸºç¡€æ¨¡æ¿
- 3.2 - a. å·¥å‚å‡½æ•°æ¨¡æ¿
- 4.1 åŸºç¡€æ¨¡æ¿
- 4.2 - a. å·¥å‚ç±»æ¨¡æ¿

ç¤ºä¾‹ï¼š

```python
import functools
import time

def timer(func):
    """Print the runtime of the decorated function"""
    @functools.wraps(func)
    def wrapper_timer(*args, **kwargs):
        start_time = time.perf_counter()
        value = func(*args, **kwargs)
        end_time = time.perf_counter()
        run_time = end_time - start_time
        print(f"Finished {func.__name__!r} in {run_time:.4f} secs")
        return value
    return wrapper_timer

@timer # æ­¤æ—¶wrapper_timeråªä¼šæµ‹é‡å®ä¾‹åŒ–TimeWasterç±»æ‰€éœ€çš„æ—¶é—´
class TimeWaster:
    def __init__(self, max_num):
        self.max_num = max_num

    def waste_time(self, num_times):
        for _ in range(num_times):
            sum([i**2 for i in range(self.max_num)])
# è£…é¥°å™¨è¯­æ³•ç­‰æ•ˆäº:TimeWaster = timer(TimeWaster)
'''
>>> tw = TimeWaster(1000)
Finished 'TimeWaster' in 0.0000 secs

>>> tw.waste_time(999)
>>>
'''
```

ç¼–å†™ç±»è£…é¥°å™¨ä¸ç¼–å†™å‡½æ•°è£…é¥°å™¨éå¸¸ç›¸ä¼¼ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯ç±»è£…é¥°å™¨å°†æ¥æ”¶ä¸€ä¸ªç±»ä½œä¸ºå‚æ•°ã€‚

### 5.1 å¯¹æ–¹æ³•è¿›è¡Œè£…é¥°

åœ¨æ–¹æ³•ä¸Šä½¿ç”¨è£…é¥°å™¨å’Œåœ¨å‡½æ•°ä¸Šä½¿ç”¨è£…é¥°å™¨æ²¡æœ‰ä»»ä½•åŒºåˆ«ã€‚

Some commonly used decorators that are even built-ins in Python are [`@classmethod`,`@staticmethod`](https://realpython.com/instance-class-and-static-methods-demystified/), and [`@property`](https://docs.python.org/library/functions.html#property). The `@classmethod` and `@staticmethod` decorators are used to define methods inside a class namespace that are not connected to a particular instance of that class. The `@property` decorator is used to customize [getters and setters](https://docs.python.org/howto/descriptor.html#properties) for class attributes. Expand the box below for an example using these decorators.

Example - The following definition of a `Circle` class uses the `@classmethod`, `@staticmethod`, and `@property` decorators:

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        """Get value of radius"""
        return self._radius

    @radius.setter
    def radius(self, value):
        """Set radius, raise error if negative"""
        if value >= 0:
            self._radius = value
        else:
            raise ValueError("Radius must be positive")

    @property
    def area(self):
        """Calculate area inside circle"""
        return self.pi() * self.radius**2

    def cylinder_volume(self, height):
        """Calculate volume of cylinder with circle as base"""
        return self.area * height

    @classmethod
    def unit_circle(cls):
        """Factory method creating a circle with radius 1"""
        return cls(1)

    @staticmethod
    def pi():
        """Value of Ï€, could use math.pi instead though"""
        return 3.1415926535
```



## 6. æ ‡å‡†åº“ä¸­çš„è£…é¥°å™¨

> è¯¦è§ï¼š
>
> - ï¹æµç•…çš„ Pythonï¹-> 7.8ã€€æ ‡å‡†åº“ä¸­çš„è£…é¥°å™¨
> - [functools â€” å‡½æ•°æ“ä½œå·¥å…·ç®±](https://pythoncaff.com/docs/pymotw/functools-function-operation-toolbox/92)
> - [9.3 è§£é™¤ä¸€ä¸ªè£…é¥°å™¨ â€”  python3-cookbook](https://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p03_unwrapping_decorator.html#id1)

Python æœ‰ä¸‰ä¸ªå†…ç½®è£…é¥°å™¨å‡½æ•°ï¼š`@property` , `@classmethod` , `@staticmethod`ã€‚

ä½¿ç”¨ `@abc.abstractmethod` å¯å®ç°æŠ½è±¡æ–¹æ³•ï¼Œè§ç¬”è®°ï¹æŠ½è±¡æ–¹æ³•.mdï¹

åœ¨æ ‡å‡†åº“çš„ `functools` æ¨¡å—ä¸­ä¹Ÿæä¾›äº†ä¸€äº›è£…é¥°å™¨ï¼Œè¿™é‡Œä»‹ç»ä¸‰ä¸ªå¸¸è§çš„ï¼š

- ğŸ”¨ @functools.lru_cache(*maxsize=128*, *typed=False*)

  è¯¥è£…é¥°å™¨å®ç°äº†å¤‡å¿˜(*memoization*)åŠŸèƒ½ï¼Œä¼šè®©æŸå‡½æ•°å…·æœ‰æœ€è¿‘æœ€å°ç¼“å­˜æœºåˆ¶( [*Least* *Recently* *Used* (LRU) *cache*](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)))ã€‚æ‰€æœ‰ä¼ é€’è¿‡æ¥çš„å‚æ•°éƒ½ä¼šè¢«å“ˆå¸ŒåŒ–ï¼Œç”¨äºåç»­ç»“æœçš„æ˜ å°„ã€‚ä¹‹åå†æ¬¡è°ƒç”¨ç›¸åŒçš„å‚æ•°æ—¶ä¼šä»ç¼“å­˜ä¸­ç›´æ¥è°ƒå–å‡ºç»“æœè€Œä¸å†ç»è¿‡å‡½æ•°è¿ç®—ã€‚åŒæ—¶æ­¤è£…é¥°å™¨è¿˜ç»™åŸå‡½æ•°åŠ äº†ä¸€ä¸ªç”¨äºæ£€æµ‹ç¼“å­˜çŠ¶æ€çš„æ–¹æ³•(`cache_info()`)å’Œä¸€ä¸ªæ¸…ç©ºç¼“å­˜çš„æ–¹æ³•(`cache_clear()`)ã€‚

- ğŸ”¨ @functools.singledispatch

  åœ¨åŠ¨æ€ç±»å‹è¯­è¨€(å¦‚ Python)ä¸­ï¼Œç»å¸¸æœ‰åœ¨æ‰§è¡Œæ—¶éœ€è¦è¾¨åˆ«ä¸åŒç±»å‹çš„å‚æ•°çš„éœ€æ±‚ï¼Œæ¯”å¦‚è¦å¤„ç†çš„æ˜¯ä¸€ä¸ªåˆ—è¡¨é‡Œçš„æ•°æ®è¿˜æ˜¯ä¸€ä¸ªå•ä¸ªçš„æ•°æ®ã€‚ç›´æ¥æ£€æµ‹å‚æ•°çš„ç±»å‹å½“ç„¶ç®€å•ï¼Œä½†ä¸åŒçš„åŠŸèƒ½ä¹Ÿå¯ä»¥å†™åˆ°ä¸åŒçš„å‡½æ•°ä¸­ï¼Œæ‰€ä»¥ `functools` æä¾›äº† `singledispatch()` è£…é¥°å™¨æ¥è®©æˆ‘ä»¬æ³¨å†Œ *æ³›å‹å‡½æ•°* ä»¥è‡ªåŠ¨åŸºäºç±»å‹è¿›è¡Œåˆ‡æ¢ã€‚

- ğŸ”¨ @functools.wraps(*wrapped*, *assigned=WRAPPER_ASSIGNMENTS*, *updated=WRAPPER_UPDATES*)

  è¯¥è£…é¥°å™¨ç”¨äºä¿ç•™åŸå§‹å‡½æ•°çš„ä¿¡æ¯ã€‚ä»æŠ€æœ¯ä¸Šæ¥è®²ï¼Œ`@functools.wraps` è£…é¥°å™¨ä¼šä½¿ç”¨ `functools.update_wrapper()` å‡½æ•°æ¥æ›´æ–°å†…çœä¸­ä½¿ç”¨çš„ç‰¹æ®Šå±æ€§ï¼Œå¦‚ `__name__` å’Œ `__doc__`ã€‚

  ä½¿ç”¨è£…é¥°å™¨åï¼ŒåŸå‡½æ•°åä¼šæŒ‡å‘è£…é¥°å™¨è¿”å›çš„å‡½æ•°ï¼Œå› æ­¤ `__name__` ç­‰å±æ€§ä¹Ÿä¼šå‘ç”Ÿå˜åŒ–ï¼Œä¾‹å¦‚ï¼š

  ```python
  def log(func):
      def wrapper(*args, **kw):
          print('call %s():' % func.__name__)
          return func(*args, **kw) 
      return wrapper
      
  @log
  def now():
      print('2017-7-21')
  
  now.__name__ #> 'wrapper'
  now()
  #> call now():
     2017-7-21
  ```

  è¿™ä¼šå¯¼è‡´æŸäº›ä¾èµ–å‡½æ•°ç­¾åçš„ä»£ç ï¼Œåœ¨æ‰§è¡Œæ—¶å‡ºé”™ã€‚ä¸ºäº†é¿å…è¿™æ ·çš„é”™è¯¯ï¼Œéœ€è¦æŠŠåŸ `now` å‡½æ•°å¯¹è±¡ä¸­çš„ `__name__` ç­‰å±æ€§å¤åˆ¶åˆ° `wrapper` å‡½æ•°å¯¹è±¡ä¸­ã€‚`functools.wraps` è£…é¥°å™¨å¯æŠŠç›¸å…³çš„å±æ€§ä» `now` å¤åˆ¶åˆ° `wrapper` ä¸­ï¼Œå¹¶ä¸éœ€è¦é¢å¤–ç¼–å†™ `wrapper.__name__ = func.__name__` è¿™æ ·çš„ä»£ç ã€‚

  å› æ­¤ï¼Œä¸€ä¸ªå®Œæ•´çš„è£…é¥°å™¨çš„å†™æ³•å¦‚ä¸‹ï¼š

  ```python
  import functools
  
  def log(func):
      @functools.wraps(func)
      def wrapper(*args, **kw):
          print('call %s():' % func.__name__)
          return func(*args, **kw)
      return wrapper
  ```

  `@functools.wraps` è¿˜æœ‰ä¸€ä¸ªé‡è¦çš„ç‰¹ç‚¹ï¼šå¯ä»¥é€šè¿‡ `__wrapped__` å†æ¬¡è®¿é—®åŸå‡½æ•°ï¼Œå¦‚ `func.__wrapped__(*args,**kwargs)`ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼š

  - å¦‚æœæœ‰å¤šä¸ªè£…é¥°å™¨åŒæ—¶ç”¨ä¸Šè¿°æ–¹æ³•è£…é¥°æŸä¸ªå‡½æ•°ï¼Œåˆ™ `__wrapped__` å¾—åˆ°çš„ç»“æœä¸å¯é¢„çŸ¥ã€‚ä¹Ÿå¯èƒ½æ˜¯åŸå‡½æ•°ï¼Œæˆ–è§£é™¤ä¸€ä¸ªè£…é¥°å™¨æ•ˆæœã€‚
  - å†…ç½®çš„è£…é¥°å™¨ `@staticmethod` å’Œ `@classmethod` å°±æ²¡æœ‰éµå¾ªè¿™ä¸ªçº¦å®š ( `@classmethod` ä¼šæŠŠåŸå§‹å‡½æ•°å­˜å‚¨åœ¨å±æ€§ `__func__` ä¸­)ã€‚




